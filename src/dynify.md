A helper macro to create dyn compatible variants for traits.

`#[dynify]` accepts a trait or function as input and returns it as is, along
with a *dynified* variant. This involves converting each input function into a
function constructor. Consider the following example:

```rust
#[dynify::dynify]
trait Client {
    async fn request(&self, uri: &str) -> String;
}
```

It expands to something like this:

```rust
# use core::future::Future;
# use dynify::{Fn, from_fn};
trait Client {
    async fn request(&self, uri: &str) -> String;
}
// A dynified trait is generated and implemented for any type that implements
// `Client`. Although this can be done without this macro, it helps stay
// synchronized with the original trait, eliminating the need to handle elided
// lifetimes, which can be quite annoying for signatures with many lifetimes.
trait DynClient {
    fn request<'this, 'uri, 'dynify>(
        &'this self,
        uri: &'uri str,
    ) -> Fn!(&'this Self, &'uri str => dyn 'dynify + Future<Output = String>)
    where
        'this: 'dynify,
        'uri: 'dynify;
}
impl<ClientImplementor: Client> DynClient for ClientImplementor {
    fn request<'this, 'uri, 'dynify>(
        &'this self,
        uri: &'uri str,
    ) -> Fn!(&'this Self, &'uri str => dyn 'dynify + Future<Output = String>)
    where
        'this: 'dynify,
        'uri: 'dynify,
    {
        from_fn!(ClientImplementor::request, self, uri)
    }
}
```

## Customizing the generated traits

You can specify an identifier as the name of the generated trait:

```rust
#[dynify::dynify(MyDynClient)]
trait Client {
    async fn request(&self, uri: &str) -> String;
}
async fn run(client: &dyn MyDynClient) {
    // ...
}
```

The identifier must be supplied as the first argument.

## Lifetime conventions

The core feature of `#[dynify]` is the expansion of
[elided lifetimes](https://doc.rust-lang.org/nomicon/lifetime-elision.html).
`#[dynify]` employs a deterministic method for this:

1. The name of each elided lifetime is based on the name of the argument that
   contains it. Therefore, the binding pattern of each argument must be an
   identifier.
2. If a lifetime is the only one, it is named exactly the same as the argument.
3. Otherwise, an index is appended to each lifetime. The index is zero-based and
   corresponds to the order in which a lifetime occurs. Both elided and named
   lifetimes are taken into account when counting indices.
4. For a method receiver, the expanded lifetime is always named based on `this`
   instead of `self`. Rule *(3)* applies in this case as well.
5. If the return type is a dyn object, it always has a bound named `'dynify`.

The following demonstrates how these rules work:

```rust
# use dynify::Fn;
# use core::future::Future;
//#[dynify::dynify]
trait Trait {
    async fn method(&self, foo: &str, bar: (&str, &str)) -> String;
}
trait DynTrait {
    fn method<'this, 'foo, 'bar0, 'bar1, 'dynify>(
        &'this self,
        foo: &'foo str,
        bar: (&'bar0 str, &'bar1 str),
    ) -> Fn!(
        &'this Self,
        &'foo str,
        (&'bar0 str, &'bar1 str)
        => dyn 'dynify + Future<Output = String>)
    where
        'this: 'dynify,
        'foo : 'dynify,
        'bar0: 'dynify,
        'bar1: 'dynify,
        // Add extra bounds here
    ;
}
```

In common cases, you can rely on the lifetimes generated by `#[dynify]`, adding
extra bounds as needed.

## Making generated traits [`Send`]able

Unlike `async-trait`, this macro does not provide support for adding `Send`
bounds to returned `Future`s (or any other `impl Trait`s). However, as
illustrated below, you can combine `#[dynify]` with
[trait-variant](https://crates.io/crates/trait-variant) to achieve this:

```rust
# use dynify::PinDynify;
// You can also use `#(make(SendClient: Send))`. However, in this case, you can
// no longer specify a name in `#[dynify]` because `#[trait_variant::make]`
// will generate two traits, which leads to conflicting trait definitions.
#[trait_variant::make(Send)]
#[dynify::dynify] // must be put within the scope of `#[trait_variant::make]`
trait Client {
    async fn request(&self, uri: &str) -> String;
}
fn run_client(
    client: &(dyn DynClient + Sync),
) -> impl '_ + std::future::Future<Output = ()> + Send {
    async move {
        client.request("http://magic/request").pin_boxed().await;
    }
}
```

As an alternative, you can also [bitte](https://crates.io/crates/bitte) for this
purpose:

<!-- TODO: enable doctest after we move to edition 2024 -->

```rust,ignore
# use dynify::PinDynify;
#[bitte::bitte(Send)]
#[dynify::dynify] // must be put within the scope of `#[bitte]`
trait Client {
    async fn request(&self, uri: &str) -> String;
}
```
